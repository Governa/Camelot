Create and edit a movie database
================================

startproject
------------

We begin with the creation of a new project. Typing the following command in
your command line interpreter creates one:

    PTC\camelot\bin\camelot-admin.py startproject videostore

PTC is the path to Camelot main directory. If Camelot is correctly installed
and working, the folder _videostore_ appears in your current working directory.
We will be working with files inside this folder.


Main window and views
---------------------

The previous command created some modules for us. Let's focus on the main 
module, _main.py_, for a moment. You use it to start your Camelot application:

    python videostore\main.py

The application has menus, a toolbar, a left navigation pane, and a central 
area on which nothing is currently displayed.

![Camelot application main window](images/picture1.png "Camelot running under Windows XP")

The navigation pane has its first button selected. Select any other button by
clicking on it, and see the nagivation tree fills itself with new entries.
These are entities, and we will talk about them later (Generally speaking, an 
entity represents a single table in a database.)

![Camelot navigation pane](images/picture2.png "Camelot's navigation pane")

Short disgression on sections: Camelot uses sections to group models. Each
button in the navigation pane represents a section, and each entry of the
navigation tree is part of this section.

Notice that we cannot do much with the menus and the toolbar; we have not
clicked on any entity yet. So let's do it (Camelot have some ready for us.)

The tabular window that appears in the previously empty area is maximized by
default. Each row in the table is a record that we can edit (save those fields
that are marked not editable.) 

![Camelot table view](images/picture3.png "Camelot application with table view")

Not all the fields appear in the table. We check this by getting a form window
of a record. Get a form window by clicking on the blue folder icon in the first
column of each record.
 
Forms are not maximized by default. And now there is more fields to edit.
Camelot echoes new fields values to the database.

That's all for basic usages of the interface.


Modeling
--------

Next we will create our videostore model. Let's first take a look at the module
_settings.py_. There is an attribute, _ENGINE_, an anonymous function, which 
returns a URI. That's the database your Camelot application will be connecting
too.

If you set a sqlite database file that does not exist, it will be created in
the directory from which the application is launched.

Now we can look at _model.py_. Camelot has already imported some classes for
us. They are used to create our entities. Let's say we want a movie entity with
a title, a short description, a release date, and a genre.

The small aforementioned specification translates into the following Python
code, that we add to our _model.py_ module:

    class Movie(Entity):
      using_options(tablename='movie')

      title = Field(Unicode(60), required=True)
      short_description = Field(Unicode(512))
      release_date = Field(Date)
      genre = Field(Unicode(15))

Movie inherits Elixir's Entity baseclass. We use using\_options() to name the 
table ourselves. Elixir would have used our module path to generate a name
in the form _package\_model\_entity_, as described on [this page] [elixir1].

[elixir1]: http://elixir.ematia.de/apidocs/elixir.options.html

Our entity holds four fields. _title_ holds up to 60 unicode characters, and is
required:

    title = Field(Unicode(60), required=True)

_short\_description_ can hold up to 512 characters:
  
    short_description = Field(Unicode(512))

_release\_date_ holds a date, and _genre_ up to 15 unicode characters:

    release_date = Field(Date)
    genre = Field(Unicode(15))

For more information about defining fields, visit [this page] [elixir2].

[elixir2]: http://elixir.ematia.de/apidocs/elixir.fields.html

The different SQLAlchemy types used by Elixir are described [here] [sqlal1].

[sqlal1]: http://www.sqlalchemy.org/docs/04/types.html

Finally, Camelot fields are documented [here] [camelot1].

[camelot1]: http://www.conceptive.be/~downloads/camelot/api/camelot.camelot.types-module.html

Let's now create an EntityAdmin subclass.


EntityAdmin subclassing
-----------------------

We have to tell Camelot about our entities, so they show up in the GUI. This is
one of the purposes of EntityAdmin subclasses. After writing the adding the
EntityAdmin subclass our Movie class now looks like this:

    class Movie(Entity):
      using_options(tablename='movie')

      title = Field(Unicode(60), required=True)
      short_description = Field(Unicode(512))
      release_date = Field(Date)
      genre = Field(Unicode(15))

      class Admin(EntityAdmin):
        name = 'Movies'
        section = 'movies'
        list_display = ['title', 'short_description', 'release_date', 'genre']

      def __repr__(self):
        return self.title or 'untitled movie'

We made Admin an inner class to emphasize the link between it and the Entity
subclass. Camelot does not force us though.

Admin holds three attributes. The value of _name_ is used in navigation trees,
while _section_'s value is used to group entities together (ie, buttons's label
in the navigation pane.) In our case the section is _'movies'_.

The last attribute is interesting; it holds a list containing fields we have
defined before. As its name suggests, _list\_display_ tells Camelot to show the
fields in the list and ignore any others fields it encounter. _list\_display_
does not affect forms though. 

In our case we want to display four fields: title, short\_description,
release\_date, and genre (well, all of them.) Next is the last piece of the
puzzle.

Lastly, we add a _\_\_repr\_\_()_ method that will return either the title of
the movie entity or _'untitled movie'_ if _title_ is empty.


application\_admin.py
--------------------

We are now working in the module _application\_admin.py_. Remember the buttons
in the navigation pane? We said they were sections, used to group entities. One
of the tasks of the module _application\_admin.py_ is to specify sections.

Camelot defines a class, _MyApplicationAdmin_, for us. This class is a subclass
of _ApplicationAdmin_, which is used to control the overall look of every 
Camelot application.

MyApplicationAdmin._\_\_init\_\_()_ calls its parent
_ApplicationAdmin.\_\_init\_\_()_ and passes it a list of sections using the
following syntax:

    (<section_name>, (<selection_display_name>, <section_icon_image>))

That means initializing ApplicationAdmin with
  
    [('relations', ('Relations', icon_relations)),
     ('configuration', ('Configurations', icon_config))]

will display two buttons in the navigation pane, labelled _'Relations'_ and
_'Configurations'_, with the specified icon next to each label. And yes, the 
order matters.

Short disgression on the class _Icon_: _Icon_ manages paths to icon resources;
it knows where to search icons using the attribute CAMELOT\_ART\_DIRECTORY in
the module _settings.py_.

Next, follows four calls to _ApplicationAdmin.register()_. As you have probably
guessed, this method registers Entities and their corresponding EntityAdmins.

We need to add a new section for our Movie entity and then register it. Camelot
comes with the Tango icon collection, we use a suitable icon for our movie
section. The call to super() in _\_\_init\_\_()_ looks like this after the
changes:

    icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
    icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
    icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

    super(MyApplicationAdmin, self).__init__([
      ('movies', ('Movies', icon_movies)),
      ('relations', ('Relations', icon_relations)),
      ('configuration', ('Configuration', icon_config)),
    ])

We now register our entity by adding this code at the very end of 
_\_\_init\_\_()_:

    from model import Movie
    self.register(Movie, Movie.Admin)

The whole _\_\_init\_\_()_ now looks like this:

    def __init__(self):
      icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
      icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
      icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

      super(MyApplicationAdmin, self).__init__([
        ('movies', ('Movies', icon_movies)),
        ('relations', ('Relations', icon_relations)),
        ('configuration', ('Configuration', icon_config)),
      ])

      from camelot.model.memento import Memento
      from camelot.model.authentication import Person, Organization
      from camelot.model.i18n import Translation
      self.register(Memento, Memento.Admin)
      self.register(Person, Person.Admin)
      self.register(Organization, Organization.Admin)
      self.register(Translation, Translation.Admin)

      from model import Movie
      self.register(Movie, Movie.Admin)

We are all set. If we run our application

    python videostore/main.py

we see a new button the navigation pane labelled _'Movies'_. Clicking on it
fills the navigation tree with the only entity in the movies's section.
Clicking on this tree entry opens a tabular view of records. And if we click on
the blue folder of each record, a form appears. 

That's it for the basics of defining an entity and setting it for display in
Camelot. Next we look at relationships between entities.


Relationships
-------------

We will be using Elixir's special fields _ManyToOne_ and _OneToMany_ to specify
relationships between entities. But first we need a _Director_ entity to play
with. We define it as follows:

    class Director(Entity):
      using_options(tablename='director')
      
      name = Field(Unicode(60))
      movies = OneToMany('Movie')

Once again, we name the table ourselves. The novelty here is _OneToMany_.

In Elixir, _OneToMany_ is a relationship; it takes as parameter the related
class's name. Behind the scenes, Elixir creates a director id column in the 
table represented by the entity _Movie_ and set a foreign key constraint on
this column.

Elixir requires that we add an inverse relationship _ManyToOne_ to our now
familiar _Movie_ entity. It ends up looking as follows:

    class Movie(Entity):
      using_options(tablename='movie')

      title = Field(Unicode(60), required=True)
      short_description = Field(Unicode(512))
      release_date = Field(Date)
      genre = Field(Unicode(15))
      director = ManyToOne('Director')

      class Admin(EntityAdmin):
        name = 'Movies'
        section = 'movies'
        list_display = ['title',
                        'short_description',
                        'release_date',
                        'genre',
                        'director']

      def __repr__(self):
        return self.title or 'untitled movie'

Our _Director_ entity needs an administration class, which adds the entity to
the section _'movies'_. We also add _\_\_repr\_\_()_ method. The entity now 
looks as follows:
      
    class Director(Entity):
      using_options(tablename='director')
      
      name = Field(Unicode(60))
      movies = OneToMany('Movie')
 
      class Admin(EntityAdmin):
        name = 'Directors'
        section = 'movies'
        list_display = ['name']

     def __repr__(self):
       return self.name or 'unknown director'

Finally, we fix _application\_admin.py_; the last lines of the _\_\_init\_\_()_
are now:

    from model import Movie, Director
    self.register(Movie, Movie.Admin)
    self.register(Director, Director.Admin)

This takes care of the relationship between our two entities. The changes
should also be reflected in the GUI.

<h1>Create a movie database application</h1>

<h2>startproject</h2>

<p>We begin with the creation of a new project. Typing the following command in
your command prompt creates one:</p>

<pre><code>PTC\camelot\bin\camelot-admin.py startproject videostore
</code></pre>

<p>Under linux, you may have to adjust the folder separator. This tutorial has
been written under the Windows XP operating system. The pictures also reflect
that operating system.</p>

<p>PTC is the path to Camelot main directory. If Camelot is correctly installed
and working, the folder <em>videostore</em> appears in your current working directory.
We will be working with the files inside this folder.</p>

<h2>Main window and views</h2>

<p>The previous command created some modules for us. Let's focus on the module
named <em>main.py</em> for a moment. It contains the entry point of your Camelot
application, which you start with:</p>

<pre><code>python videostore\main.py
</code></pre>

<p>You should get the picture we display below:</p>

<p><img src="images/picture1.png" alt="Camelot application main window" title="Camelot running under Windows XP" /></p>

<p>The application has menus, a toolbar, a left navigation pane, and a central
area on which nothing is currently displayed.</p>

<p>The navigation pane has its first button selected. Select any other button by
clicking on it, and see the nagivation tree fills itself with new entries.
These are entities, and we will talk about them later (Generally speaking, an 
entity represents a single table in a database.)</p>

<p><img src="images/picture2.png" alt="Camelot navigation pane" title="Camelot's navigation pane" /></p>

<p>Short disgression on sections: Camelot uses sections to group models. Each
button in the navigation pane represents a section, and each entry of the
navigation tree is part of this section.</p>

<p>Notice that the application disables most of the menus and the toolbar buttons.
When we click on an entity, more options become available. So let's click on
the entity named <em>Persons</em> in the section <em>relations</em>. A child window appears
in the previously empty area and is maximized by default: this is the table
view of the entity named <em>Persons</em>.</p>

<p><img src="images/picture3.png" alt="Camelot table view" title="Camelot application with table view" /></p>

<p>Each row is a record with some fields that we can edit (other fields may not be
editable). Let's now add a new row by clicking on the new document icon (next
to the trash bin icon -- which removes a row).</p>

<p><img src="images/picture4.png" alt="Camelot toolbar add/remove icons" title="Add or delete a row" /></p>

<p>We now see a form view with additional fields. Forms are not maximized by
default. Forms label required fields in bold.</p>

<p><img src="images/picture5.png" alt="Camelot form view" title="Filling a form" /></p>

<p>Fill in a first and a last name, and close the form. Camelot will automatically
validate and echo the changes to the database. We can reopen the form by
clicking on the blue icon in the first column of each row of the table.</p>

<p><img src="images/picture6.png" alt="Camelot table view with record" title="The new record appears in the table view as well" /></p>

<p>That's all for basic usages of the interface.</p>

<h2>Modeling</h2>

<p>Next we will create our videostore model. Let's first take a look at the module
<em>settings.py</em>. There is an attribute, <em>ENGINE</em>, an anonymous function, which 
returns a URI, a uniform resource identifier. That's the database your Camelot
application will be connecting too. Camelot provides a default sqlite URI
scheme. But you can set your own.</p>

<p>If you set a sqlite database file that does not exist, for example, it will be
created in the directory from which the application is launched.</p>

<p>Now we can look at <em>model.py</em>. Camelot has already imported some classes for
us. They are used to create our entities. Let's say we want a movie entity with
a title, a short description, a release date, and a genre.</p>

<p>The small aforementioned specification translates into the following Python
code, that we add to our <em>model.py</em> module:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movie')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))
</code></pre>

<p>Movie inherits Elixir's Entity baseclass. We use using_options() to name the 
table ourselves. Elixir would have used our module path to generate a name
in the form <em>package_model_entity</em>, as described on <a href="http://elixir.ematia.de/apidocs/elixir.options.html">this page</a>.</p>

<p>Our entity holds four fields. <em>title</em> holds up to 60 unicode characters, and is
required:</p>

<pre><code>title = Field(Unicode(60), required=True)
</code></pre>

<p><em>short_description</em> can hold up to 512 characters:</p>

<pre><code>short_description = Field(Unicode(512))
</code></pre>

<p><em>release_date</em> holds a date, and <em>genre</em> up to 15 unicode characters:</p>

<pre><code>release_date = Field(Date)
genre = Field(Unicode(15))
</code></pre>

<p>For more information about defining fields, visit <a href="http://elixir.ematia.de/apidocs/elixir.fields.html">this page</a>.</p>

<p>The different SQLAlchemy types used by Elixir are described <a href="http://www.sqlalchemy.org/docs/04/types.html">here</a>.</p>

<p>Finally, Camelot fields are documented <a href="http://www.conceptive.be/~downloads/camelot/api/camelot.camelot.types-module.html">here</a>.</p>

<p>Let's now create an EntityAdmin subclass.</p>

<h2>EntityAdmin subclassing</h2>

<p>We have to tell Camelot about our entities, so they show up in the GUI. This is
one of the purposes of EntityAdmin subclasses. After adding the EntityAdmin
subclass, our Movie class now looks like this:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movie')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))

  class Admin(EntityAdmin):
    name = 'Movies'
    section = 'movies'
    list_display = ['title', 'short_description', 'release_date', 'genre']

  def __repr__(self):
    return self.title or 'untitled movie'
</code></pre>

<p>We made Admin an inner class to emphasize the link between it and the Entity
subclass. Camelot does not force us though.</p>

<p>Admin holds three attributes. The value of <em>name</em> will be a label in navigation
trees, while <em>section</em>'s value is used programmatically to group entities
together (we will see that soon). In our case, our group/section is <em>'movies'</em>.</p>

<p>The last attribute is interesting; it holds a list containing the fields we
have defined above. As the name suggests, <em>list_display</em> tells Camelot to show
the fields in the list and ignore any others fields it finds. <em>list_display</em>
does not affect forms though. </p>

<p>In our case we want to display four fields: <em>title</em>, <em>short_description</em>,
<em>release_date</em>, and <em>genre</em> (well, all of them.) </p>

<p>Lastly, we add a <em>__repr__()</em> method that will return either the title of
the movie entity or <em>'untitled movie'</em> if <em>title</em> is empty.</p>

<p>Let's move onto the last piece of the puzzle.</p>

<h2>application_admin.py</h2>

<p>We are now working in the module <em>application_admin.py</em>. Remember the buttons
in the navigation pane? We said they were sections, used to group entities. One
of the tasks of the module <em>application_admin.py</em> is to specify sections.</p>

<p>Camelot defines a class, <em>MyApplicationAdmin</em>, for us. This class is a subclass
of <em>ApplicationAdmin</em>, which is used to control the overall look and feel of
every Camelot application.</p>

<p>MyApplicationAdmin.<em>__init__()</em> calls its parent
<em>ApplicationAdmin.__init__()</em> and passes it a list of sections using the
following syntax:</p>

<pre><code>(&lt;section_internal_name&gt;, (&lt;section_label&gt;, &lt;section_icon_image&gt;))
</code></pre>

<p>That means initializing ApplicationAdmin with</p>

<pre><code>[('relations', ('Relations', icon_relations)),
 ('configuration', ('Configurations', icon_config))]
</code></pre>

<p>will display two buttons in the navigation pane, labelled <em>'Relations'</em> and
<em>'Configurations'</em>, with the specified icon next to each label. And yes, the 
order matters.</p>

<p>Short disgression on the class <em>Icon</em>: <em>Icon</em> manages paths to icon resources;
it knows where to search icons using the attribute CAMELOT_ART_DIRECTORY in
the module <em>settings.py</em>.</p>

<p>Next, follows four calls to <em>ApplicationAdmin.register()</em>. As you have probably
guessed, this method registers Entities and their corresponding EntityAdmins.</p>

<p>We need to add a new section for our Movie entity and then register it. Camelot
comes with the Tango icon collection; we use a suitable icon for our movie
section. The call to super() in <em>__init__()</em> looks like this after the
changes:</p>

<pre><code>icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

super(MyApplicationAdmin, self).__init__([
  ('movies', ('Movies', icon_movies)),
  ('relations', ('Relations', icon_relations)),
  ('configuration', ('Configuration', icon_config)),
])
</code></pre>

<p>We now register our entity by adding this code at the very end of 
<em>__init__()</em>:</p>

<pre><code>from model import Movie
self.register(Movie, Movie.Admin)
</code></pre>

<p>The whole <em>__init__()</em> now looks like this:</p>

<pre><code>def __init__(self):
  icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
  icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
  icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

  super(MyApplicationAdmin, self).__init__([
    ('movies', ('Movies', icon_movies)),
    ('relations', ('Relations', icon_relations)),
    ('configuration', ('Configuration', icon_config)),
  ])

  from camelot.model.memento import Memento
  from camelot.model.authentication import Person, Organization
  from camelot.model.i18n import Translation
  self.register(Memento, Memento.Admin)
  self.register(Person, Person.Admin)
  self.register(Organization, Organization.Admin)
  self.register(Translation, Translation.Admin)

  from model import Movie
  self.register(Movie, Movie.Admin)
</code></pre>

<p>We are all set. If we run our application,</p>

<pre><code>python videostore/main.py
</code></pre>

<p>we see a new button the navigation pane labelled <em>'Movies'</em>. Clicking on it
fills the navigation tree with the only entity in the movies's section.
Clicking on this tree entry opens a tabular view of records. And if we click on
the blue folder of each record, a form appears.</p>

<p>See our movie database in action:</p>

<p><img src="images/picture7.png" alt="Camelot movie database application" title="Our movie database" /></p>

<p>That's it for the basics of defining an entity and setting it for display in
Camelot. Next we look at relationships between entities.</p>

<h2>Relationships</h2>

<p>We will be using Elixir's special fields <em>ManyToOne</em> and <em>OneToMany</em> to specify
relationships between entities. But first we need a <em>Director</em> entity to play
with. We define it as follows:</p>

<pre><code>class Director(Entity):
  using_options(tablename='director')

  name = Field(Unicode(60))
  movies = OneToMany('Movie')
</code></pre>

<p>Once again, we name the table ourselves. The novelty here is <em>OneToMany</em>.</p>

<p>In Elixir, <em>OneToMany</em> is a relationship; it takes as parameter the related
class's name. Behind the scenes, Elixir creates a director id column in the 
table represented by the entity <em>Movie</em> and set a foreign key constraint on
this column.</p>

<p>Elixir requires that we add an inverse relationship <em>ManyToOne</em> to our now
familiar <em>Movie</em> entity. It ends up looking as follows:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movie')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))
  director = ManyToOne('Director')

  class Admin(EntityAdmin):
    name = 'Movies'
    section = 'movies'
    list_display = ['title',
                    'short_description',
                    'release_date',
                    'genre',
                    'director']

  def __repr__(self):
    return self.title or 'untitled movie'
</code></pre>

<p>Our <em>Director</em> entity needs an administration class, which adds the entity to
the section <em>'movies'</em>. We also add <em>__repr__()</em> method. The entity now 
looks as follows:</p>

<pre><code>class Director(Entity):
  using_options(tablename='director')

  name = Field(Unicode(60))
  movies = OneToMany('Movie')

  class Admin(EntityAdmin):
    name = 'Directors'
    section = 'movies'
    list_display = ['name']

  def __repr__(self):
    return self.name or 'unknown director'
</code></pre>

<p>The two entities are once again listed below:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movie')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))
  director = ManyToOne('Director')

  class Admin(EntityAdmin):
    name = 'Movies'
    section = 'movies'
    list_display = ['title',
                    'short_description',
                    'release_date',
                    'genre',
                    'director']

  def __repr__(self):
    return self.title or 'untitled movie'


class Director(Entity):
  using_options(tablename='director')

  name = Field(Unicode(60))
  movies = OneToMany('Movie')

  class Admin(EntityAdmin):
    name = 'Directors'
    section = 'movies'
    list_display = ['name']

  def __repr__(self):
    return self.name or 'unknown director'
</code></pre>

<p>Finally, we fix <em>application_admin.py</em>; the last lines of the <em>__init__()</em>
are now:</p>

<pre><code>from model import Movie, Director
self.register(Movie, Movie.Admin)
self.register(Director, Director.Admin)
</code></pre>

<p>This takes care of the relationship between our two entities. This should be
the new look of our application:</p>

<p><img src="images/picture8.png" alt="Camelot movie database application" title="We have relationships between entities now!" /></p>

<p>We have just learned the basics of Camelot, and have a nice movie database
application that we can play with. In another tutorial, we will learn more
advanced features of Camelot.</p>

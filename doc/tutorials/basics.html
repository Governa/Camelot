<h1>Create and edit a movie database</h1>

<h2>startproject</h2>

<p>We begin with the creation of a new project. Typing the following command in
your command line interpreter creates one:</p>

<pre><code>PTC\camelot\bin\camelot-admin.py startproject videostore
</code></pre>

<p>PTC is the path to Camelot main directory. If Camelot is correctly installed
and working, the folder <em>videostore</em> appears in your current working directory.
We will be working with files inside this folder.</p>

<h2>Main window and views</h2>

<p>The previous command created some modules for us. Let's focus on the main 
module, <em>main.py</em>, for a moment. You use it to start your Camelot application:</p>

<pre><code>python videostore\main.py
</code></pre>

<p><img src="images/picture1.png" alt="Camelot application main window" title="" /></p>

<p>The application has menus, a toolbar, a left navigation pane, and a central 
area on which nothing is currently displayed.</p>

<p>The navigation pane has its first button selected. Select any other button by
clicking on it, and see the nagivation tree fills itself with new entries.
These are entities, and we will talk about them later (Generally speaking, an 
entity represents a single table in a database.)</p>

<p><img src="images/picture2.png" alt="Camelot navigation pane" title="" /></p>

<p>Short disgression on sections: Camelot uses sections to group models. Each
button in the navigation pane represents a section, and each entry of the
navigation tree is part of this section.</p>

<p>Notice that we cannot do much with the menus and the toolbar; we have not
clicked on any entity yet. So let's do it (Camelot have some ready for us.)</p>

<p>The tabular window that appears in the previously empty area is maximized by
default. Each row in the table is a record that we can edit (save those fields
that are marked not editable.) </p>

<p><img src="images/picture3.png" alt="Camelot table view" title="" /></p>

<p>Not all the fields appear in the table. We check this by getting a form window
of a record. Get a form window by clicking on the blue folder icon in the first
column of each record.</p>

<p>Forms are not maximized by default. And now there is more fields to edit.
Camelot echoes new fields values to the database.</p>

<p><img src="images/picture4.png" alt="Camelot form view" title="" /></p>

<p>That's all for basic usages of the interface.</p>

<h2>Modeling</h2>

<p>Next we will create our videostore model. Let's first take a look at the module
<em>settings.py</em>. There is an attribute, <em>ENGINE</em>, an anonymous function, which 
returns a URI. That's the database your Camelot application will be connecting
too.</p>

<p>If you set a sqlite database file that does not exist, it will be created in
the directory from which the application is launched.</p>

<p>Now we can look at <em>model.py</em>. Camelot has already imported some classes for
us. They are used to create our entities. Let's say we want a movie entity with
a title, a short description, a release date, and a genre.</p>

<p>The small aforementioned specification translates to the following Python code,
that we add to our <em>model.py</em> module:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movies')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))
</code></pre>

<p>Movie inherits Elixir's Entity baseclass. We use using_options() to name the 
table ourselves. Elixir would have used our module path to generate a name
in the form <em>package_model_entity</em>, as described on <a href="http://elixir.ematia.de/apidocs/elixir.options.html">this page</a>.</p>

<p>Our entity holds four fields. <em>title</em> holds up to 60 unicode characters, and is
required:</p>

<pre><code>title = Field(Unicode(60), required=True)
</code></pre>

<p><em>short_description</em> can hold up to 512 characters:</p>

<pre><code>short_description = Field(Unicode(512))
</code></pre>

<p><em>release_date</em> holds a date, and <em>genre</em> up to 15 unicode characters:</p>

<pre><code>release_date = Field(Date)
genre = Field(Unicode(15))
</code></pre>

<p>For more information about defining fields, visit <a href="http://elixir.ematia.de/apidocs/elixir.fields.html">this page</a>.</p>

<p>The different SQLAlchemy types used by Elixir are described <a href="http://www.sqlalchemy.org/docs/04/types.html">here</a>.</p>

<p>Finally, Camelot fields are documented <a href="http://www.conceptive.be/~downloads/camelot/api/camelot.camelot.types-module.html">here</a>.</p>

<p>Let's now create an EntityAdmin subclass.</p>

<h2>EntityAdmin subclassing</h2>

<p>We have to tell Camelot about our entities, so they show up in the GUI. This is
one of the purposes of EntityAdmin subclasses. After writing the adding the
EntityAdmin subclass our Movie class now looks like this:</p>

<pre><code>class Movie(Entity):
  using_options(tablename='movies')

  title = Field(Unicode(60), required=True)
  short_description = Field(Unicode(512))
  release_date = Field(Date)
  genre = Field(Unicode(15))

  class Admin(EntityAdmin):
    name = 'Movies'
    section = 'movies'
    list_display = ['title', 'short_description', 'release_date', 'genre']
</code></pre>

<p>We made Admin an inner class to emphasize the link between it and the Entity
subclass. Camelot does not force us though.</p>

<p>Admin holds three attributes. The value of <em>name</em> is used in navigation trees,
while <em>section</em>'s value is used to group entities together (ie, buttons's label
in the navigation pane.) In our case the section is <em>'movies'</em>.</p>

<p>The last attribute is interesting; it holds a list containing fields we have
defined before. As its name suggests, <em>list_display</em> tells Camelot to show the
fields in the list and ignore any others fields it encounter. <em>list_display</em>
does not affect forms though. </p>

<p>In our case we want to display four fields: title, short_description,
release_date, and genre (well, all of them.) Next is the last piece of the
puzzle.</p>

<h2>application_admin.py</h2>

<p>We are now working in the module <em>application_admin.py</em>. Remember the buttons
in the navigation pane? We said they were sections, used to group entities. One
of the tasks of the module <em>application_admin.py</em> is to specify sections.</p>

<p>Camelot defines a class, <em>MyApplicationAdmin</em>, for us. This class is a subclass
of <em>ApplicationAdmin</em>, which is used to control the overall look of every 
Camelot application.</p>

<p>MyApplicationAdmin.<em>__init__()</em> calls its parent
<em>ApplicationAdmin.__init__()</em> and passes it a list of sections using the
following syntax:</p>

<pre><code>(&lt;section_name&gt;, (&lt;selection_display_name&gt;, &lt;section_icon_image&gt;))
</code></pre>

<p>That means initializing ApplicationAdmin with</p>

<pre><code>[('relations', ('Relations', icon_relations)),
 ('configuration', ('Configurations', icon_config))]
</code></pre>

<p>will display two buttons in the navigation pane, labelled <em>'Relations'</em> and
<em>'Configurations'</em>, with the specified icon next to each label. And yes, the 
order matters.</p>

<p>Short disgression on the class <em>Icon</em>: <em>Icon</em> manages paths to icon resources;
it knows where to search icons using the attribute CAMELOT_ART_DIRECTORY in
the module <em>settings.py</em>.</p>

<p>Next, follows four calls to <em>ApplicationAdmin.register()</em>. As you have probably
guessed, this method registers Entities and their corresponding EntityAdmins.</p>

<p>We need to add a new section for our Movie entity and then register it. Camelot
comes with the Tango icon collection, we use a suitable icon for our movie
section. The call to super() in <em>__init__()</em> looks like this after the
changes:</p>

<pre><code>icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

super(MyApplicationAdmin, self).__init__([
  ('movies', ('Movies', icon_movies)),
  ('relations', ('Relations', icon_relations)),
  ('configuration', ('Configuration', icon_config)),
])
</code></pre>

<p>We now register our entity by adding this code at the very end of 
<em>__init__()</em>:</p>

<pre><code>from model import Movie
self.register(Movie, Movie.Admin)
</code></pre>

<p>The whole <em>__init__()</em> now looks like this:</p>

<pre><code>def __init__(self):
  icon_movies = Icon('tango/24x24/categories/applications-multimedia.png').fullpath()
  icon_relations = Icon('tango/24x24/apps/system-users.png').fullpath()
  icon_config = Icon('tango/24x24/categories/preferences-system.png').fullpath()

  super(MyApplicationAdmin, self).__init__([
    ('movies', ('Movies', icon_movies)),
    ('relations', ('Relations', icon_relations)),
    ('configuration', ('Configuration', icon_config)),
  ])

  from camelot.model.memento import Memento
  from camelot.model.authentication import Person, Organization
  from camelot.model.i18n import Translation
  self.register(Memento, Memento.Admin)
  self.register(Person, Person.Admin)
  self.register(Organization, Organization.Admin)
  self.register(Translation, Translation.Admin)

  from model import Movie
  self.register(Movie, Movie.Admin)
</code></pre>

<p>We are all set. If we run our application</p>

<pre><code>python videostore/main.py
</code></pre>

<p>we see a new button the navigation pane labelled <em>'Movies'</em>. Clicking on it
fills the navigation tree with the only entity in the movies's section.
Clicking on this tree entry opens a tabular view of records. And if we click on
the blue folder of each record, a form appears. </p>

<p>That's it for the basics of Camelot.</p>
